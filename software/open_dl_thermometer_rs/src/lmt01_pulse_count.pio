.program lmt01_pulse_count
; Count pulses on input pin until CPU sends any data, then send count to FIFO.define
; CPU must negate count to get the number of pulses.

; If CPU does not send send data before 2^32 pulses are counted, 
; the pulse count (2^32) will be pushed to the fifo and a new count will start.


.wrap_target
; Set Y to 0xFFFFFFFF. We count downwards since we can only decrement. Could do this outside the PIO with pio_sm_exec if needed
mov y !null 

loop:
; CPU sends us dummy data to FIFO when it wants the count. Check if we've received anything (from autopull).
jmp !osre respond 
; Wait for high on the 0th pin as configured in PINCTRL_IN_BASE
wait 1 pin 0 
; Wait for low  on the 0th pin as configured in PINCTRL_IN_BASE
wait 0 pin 0 
; Decrement Y and loop. We mostly assume the CPU will send us something before Y reaches 0. If it does reach zero we push the count onto the RX FIFO and continue counting
jmp y-- loop

respond:
; Discard output shift register data we just autopulled. Could do this outside the PIO with pio_sm_exec if needed
out null 32 
; Push pulse count to ISR. Autopush will push to FIFO. CPU must negate to undo the inversion from counting downwards
in y 32 
.wrap

% c-sdk {
static inline void hello_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = hello_program_get_default_config(offset);

    // Map the state machine's IN pin group to one pin, namely the `pin`
    // parameter to this function.
    sm_config_set_in_pins(&c, pin, 1);
    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin);
    // Set the pin direction to input at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);

    // Enable autopull and autopush
    sm_config_set_in_shift(&c, true, true, 32);
    sm_config_set_out_shift(&c, true, true, 32);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}